/**
 * Enhanced Agent Wrappers Hook with Unified Storage Integration
 * 
 * React hook that integrates the existing agent wrapper functionality with the unified storage system
 * for persistent agent data and real-time synchronization.
 */

import { useState, useEffect, useCallback } from 'react';
import { agentManagementServiceUnified } from '../../../services/agentManagementServiceUnified';
import { AgentWrapper, WrapperMetrics } from '../types';
import { storageExtension } from '../../../extensions/StorageExtension';

// Enhanced types for the hook
interface StoredAgentWrapper extends AgentWrapper {
  userId: string;
  createdAt: number;
  lastModified: number;
  isActive: boolean;
  deploymentStatus: 'draft' | 'deployed' | 'suspended' | 'archived';
  usageMetrics: {
    totalRequests: number;
    successfulRequests: number;
    failedRequests: number;
    averageResponseTime: number;
    lastUsed: number;
  };
  governanceData: {
    trustScore: number;
    complianceScore: number;
    violations: number;
    lastAudit: number;
  };
}

interface UseAgentWrappersReturn {
  // Data
  wrappers: StoredAgentWrapper[];
  activeWrappers: StoredAgentWrapper[];
  metrics: WrapperMetrics | null;
  
  // Loading states
  loading: boolean;
  creating: boolean;
  updating: boolean;
  deleting: boolean;
  
  // Error states
  error: string | null;
  
  // Actions
  createWrapper: (wrapper: Omit<AgentWrapper, 'id'>) => Promise<string>;
  updateWrapper: (id: string, updates: Partial<StoredAgentWrapper>) => Promise<void>;
  deleteWrapper: (id: string) => Promise<void>;
  deployWrapper: (id: string) => Promise<void>;
  suspendWrapper: (id: string) => Promise<void>;
  archiveWrapper: (id: string) => Promise<void>;
  refreshWrappers: () => Promise<void>;
  recordUsage: (id: string, success: boolean, responseTime: number) => Promise<void>;
  
  // Utilities
  getWrapperById: (id: string) => StoredAgentWrapper | undefined;
  getWrappersByProvider: (provider: string) => StoredAgentWrapper[];
  getWrappersByStatus: (status: string) => StoredAgentWrapper[];
  isStorageReady: boolean;
}

export const useAgentWrappersUnified = (userId?: string): UseAgentWrappersReturn => {
  // State
  const [wrappers, setWrappers] = useState<StoredAgentWrapper[]>([]);
  const [metrics, setMetrics] = useState<WrapperMetrics | null>(null);
  const [loading, setLoading] = useState(true);
  const [creating, setCreating] = useState(false);
  const [updating, setUpdating] = useState(false);
  const [deleting, setDeleting] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [isStorageReady, setIsStorageReady] = useState(false);

  // Initialize service with user ID
  useEffect(() => {
    const initializeService = async () => {
      if (userId) {
        try {
          await agentManagementServiceUnified.setUserId(userId);
          setIsStorageReady(agentManagementServiceUnified.isStorageIntegrationReady());
          await refreshWrappers();
        } catch (err) {
          setError(err instanceof Error ? err.message : 'Failed to initialize agent service');
        }
      }
    };

    initializeService();
  }, [userId]);

  // Refresh wrappers from storage
  const refreshWrappers = useCallback(async () => {
    if (!userId) return;

    try {
      setLoading(true);
      setError(null);
      
      const storedWrappers = await agentManagementServiceUnified.getStoredAgentWrappers();
      setWrappers(storedWrappers);
      
      // Calculate metrics
      const agentMetrics = await agentManagementServiceUnified.getAgentManagementMetrics();
      setMetrics({
        totalWrappers: agentMetrics.totalAgents,
        activeWrappers: agentMetrics.activeWrappers,
        totalRequests: agentMetrics.totalRequests,
        averageResponseTime: storedWrappers.length > 0 
          ? storedWrappers.reduce((sum, w) => sum + w.usageMetrics.averageResponseTime, 0) / storedWrappers.length 
          : 0,
        successRate: agentMetrics.totalRequests > 0 
          ? storedWrappers.reduce((sum, w) => sum + w.usageMetrics.successfulRequests, 0) / agentMetrics.totalRequests * 100
          : 0
      });
      
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to load agent wrappers');
    } finally {
      setLoading(false);
    }
  }, [userId]);

  // Create new wrapper
  const createWrapper = useCallback(async (wrapper: Omit<AgentWrapper, 'id'>): Promise<string> => {
    if (!userId) throw new Error('User ID required');

    try {
      setCreating(true);
      setError(null);
      
      const wrapperId = await agentManagementServiceUnified.createAgentWrapper({
        ...wrapper,
        id: '' // Will be generated by the service
      });
      
      await refreshWrappers();
      return wrapperId;
      
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to create agent wrapper';
      setError(errorMessage);
      throw new Error(errorMessage);
    } finally {
      setCreating(false);
    }
  }, [userId, refreshWrappers]);

  // Update wrapper
  const updateWrapper = useCallback(async (id: string, updates: Partial<StoredAgentWrapper>): Promise<void> => {
    if (!userId) throw new Error('User ID required');

    try {
      setUpdating(true);
      setError(null);
      
      await agentManagementServiceUnified.updateAgentWrapper(id, updates);
      await refreshWrappers();
      
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to update agent wrapper';
      setError(errorMessage);
      throw new Error(errorMessage);
    } finally {
      setUpdating(false);
    }
  }, [userId, refreshWrappers]);

  // Delete wrapper
  const deleteWrapper = useCallback(async (id: string): Promise<void> => {
    if (!userId) throw new Error('User ID required');

    try {
      setDeleting(true);
      setError(null);
      
      await agentManagementServiceUnified.deleteAgentWrapper(id);
      await refreshWrappers();
      
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to delete agent wrapper';
      setError(errorMessage);
      throw new Error(errorMessage);
    } finally {
      setDeleting(false);
    }
  }, [userId, refreshWrappers]);

  // Deploy wrapper
  const deployWrapper = useCallback(async (id: string): Promise<void> => {
    await updateWrapper(id, { 
      deploymentStatus: 'deployed',
      isActive: true 
    });
  }, [updateWrapper]);

  // Suspend wrapper
  const suspendWrapper = useCallback(async (id: string): Promise<void> => {
    await updateWrapper(id, { 
      deploymentStatus: 'suspended',
      isActive: false 
    });
  }, [updateWrapper]);

  // Archive wrapper
  const archiveWrapper = useCallback(async (id: string): Promise<void> => {
    await updateWrapper(id, { 
      deploymentStatus: 'archived',
      isActive: false 
    });
  }, [updateWrapper]);

  // Record usage
  const recordUsage = useCallback(async (id: string, success: boolean, responseTime: number): Promise<void> => {
    if (!userId) return;

    try {
      await agentManagementServiceUnified.recordAgentUsage(id, success, responseTime);
      // Optionally refresh wrappers to show updated metrics
      // await refreshWrappers();
    } catch (err) {
      console.error('Failed to record agent usage:', err);
    }
  }, [userId]);

  // Utility functions
  const getWrapperById = useCallback((id: string): StoredAgentWrapper | undefined => {
    return wrappers.find(wrapper => wrapper.id === id);
  }, [wrappers]);

  const getWrappersByProvider = useCallback((provider: string): StoredAgentWrapper[] => {
    return wrappers.filter(wrapper => 
      wrapper.supportedProviders.includes(provider)
    );
  }, [wrappers]);

  const getWrappersByStatus = useCallback((status: string): StoredAgentWrapper[] => {
    return wrappers.filter(wrapper => wrapper.deploymentStatus === status);
  }, [wrappers]);

  // Computed values
  const activeWrappers = wrappers.filter(wrapper => 
    wrapper.isActive && wrapper.deploymentStatus === 'deployed'
  );

  // Set up storage event listeners for real-time updates
  useEffect(() => {
    if (!isStorageReady) return;

    const handleStorageEvent = (event: any) => {
      if (event.namespace === 'agents' && event.key.startsWith('wrapper_')) {
        // Refresh wrappers when storage changes
        refreshWrappers();
      }
    };

    const removeListener = storageExtension.addEventListener(handleStorageEvent);
    return removeListener;
  }, [isStorageReady, refreshWrappers]);

  return {
    // Data
    wrappers,
    activeWrappers,
    metrics,
    
    // Loading states
    loading,
    creating,
    updating,
    deleting,
    
    // Error states
    error,
    
    // Actions
    createWrapper,
    updateWrapper,
    deleteWrapper,
    deployWrapper,
    suspendWrapper,
    archiveWrapper,
    refreshWrappers,
    recordUsage,
    
    // Utilities
    getWrapperById,
    getWrappersByProvider,
    getWrappersByStatus,
    isStorageReady
  };
};

// Backward compatibility - export the original hook name
export const useAgentWrappers = useAgentWrappersUnified;

