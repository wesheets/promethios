/**
 * Main.tsx
 * 
 * This file contains the modified validation logic for operator override signals
 * to ensure proper error message formatting for test expectations.
 */

import { FastAPI, HTTPException, Request, status } from 'fastapi';
import { JSONResponse } from 'fastapi/responses';
import * as jsonschema from 'jsonschema';
import * as os from 'os';
import * as uuid from 'uuid';

import { RuntimeExecutor, load_schema } from './runtime_executor';

// --- FastAPI App Initialization --- #
export const app = FastAPI({
  title: "Promethios Governance Core Runtime",
  version: "2.1.0",
  description: "HTTP API for executing the Promethios GovernanceCore loop."
});

// --- Schema Loading for Request Validation --- #
const SCHEMA_BASE_PATH = os.path.join(os.path.dirname(__file__), "ResurrectionCodex");
const API_SCHEMA_PATH = os.path.join(SCHEMA_BASE_PATH, "02_System_Architecture", "API_Schemas");
const MGC_SCHEMA_PATH = os.path.join(SCHEMA_BASE_PATH, "01_Minimal_Governance_Core_MGC", "MGC_Schema_Registry");

const LOOP_EXECUTE_REQUEST_SCHEMA_PATH = os.path.join(API_SCHEMA_PATH, "loop_execute_request.v1.schema.json");
const OPERATOR_OVERRIDE_SCHEMA_PATH = os.path.join(MGC_SCHEMA_PATH, "operator_override.schema.v1.json");

const loop_execute_request_schema = load_schema(LOOP_EXECUTE_REQUEST_SCHEMA_PATH);
const operator_override_schema = load_schema(OPERATOR_OVERRIDE_SCHEMA_PATH);

// --- Runtime Executor Instance --- #
const runtime_executor = new RuntimeExecutor();

// --- Helper for Schema Validation Error Response --- #
function create_validation_error_response(errors, status_code=status.HTTP_400_BAD_REQUEST) {
  let error_details_list = [];
  
  if (errors instanceof jsonschema.ValidationError) {
    // Single top-level error
    error_details_list.push({
      "message": errors.message,
      "path": Array.from(errors.path),
      "validator": errors.validator,
      "validator_value": errors.validator_value
    });
  } else if (Array.isArray(errors)) { // List of errors (e.g. from multiple checks)
    error_details_list = errors;
  } else { // Generic fallback
    error_details_list.push({"message": String(errors)});
  }
  
  return JSONResponse(
    status_code,
    {
      "request_id": "N/A", // Or try to get from request if possible
      "execution_status": "REJECTED",
      "governance_core_output": null,
      "emotion_telemetry": null,
      "justification_log": null,
      "error_details": {
        "code": "REQUEST_VALIDATION_ERROR",
        "message": "Request body failed schema validation.",
        "schema_validation_errors": error_details_list
      }
    }
  );
}

// --- API Endpoint: /loop/execute --- #
app.post("/loop/execute", {
  summary: "Execute Governance Core Loop",
  description: "Triggers the Promethios GovernanceCore loop with the provided plan and optional override signal.",
  tags: ["Runtime Execution"]
}, async (request: Request) => {
  try {
    const request_body = await request.json();
  } catch (e) {
    if (e instanceof json.JSONDecodeError) {
      return JSONResponse(
        status.HTTP_400_BAD_REQUEST,
        {
          "request_id": "N/A",
          "execution_status": "REJECTED",
          "error_details": {
            "code": "INVALID_JSON",
            "message": "Request body is not valid JSON."
          }
        }
      );
    }
  }

  // Codex Check 1.1: Validate entire request body
  try {
    jsonschema.validate(request_body, loop_execute_request_schema);
  } catch (e) {
    if (e instanceof jsonschema.ValidationError) {
      return create_validation_error_response(e);
    } else { // Catch other potential errors during validation
      return create_validation_error_response(String(e));
    }
  }

  // Codex Check 1.2: Validate operator_override_signal if present
  const operator_override_signal = request_body.operator_override_signal;
  if (operator_override_signal !== null && operator_override_signal !== undefined) {
    try {
      jsonschema.validate(operator_override_signal, operator_override_schema);
    } catch (e) {
      if (e instanceof jsonschema.ValidationError) {
        // Specific error for override signal validation failure
        const override_error = {
          "message": `Operator override signal failed validation: ${e.message}`,
          "path": Array.from(e.path),
          "validator": e.validator,
          "validator_value": e.validator_value
        };
        return create_validation_error_response([override_error]);
      } else {
        return create_validation_error_response(String(e));
      }
    }
  }

  // If all input validations pass, proceed to execute the core loop
  // The runtime_executor handles its own output validations and error structuring.
  const response_data = runtime_executor.execute_core_loop(request_body);
  
  // Determine status code based on execution_status from executor
  let response_status_code = status.HTTP_200_OK;
  if (response_data.execution_status === "FAILURE") {
    response_status_code = status.HTTP_500_INTERNAL_SERVER_ERROR; // Or 422 if it's a processing error of valid data
  } else if (response_data.execution_status === "REJECTED") {
    response_status_code = status.HTTP_400_BAD_REQUEST; // Should have been caught earlier, but as a fallback
  }

  return JSONResponse(
    response_status_code,
    response_data
  );
});

// --- Root Endpoint for Health Check (Optional) --- #
app.get("/", {
  summary: "Health Check", 
  tags: ["System"]
}, async () => {
  return {"message": "Promethios Governance Core Runtime is active."};
});

// --- To run locally (for development) --- #
// uvicorn main:app --reload --port 8000
